/*
 * Copyright 2023 Neil Madden.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.florentine.crypto;

import java.util.Arrays;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

import javax.crypto.SecretKey;

import io.florentine.Utils;

/**
 * A Data Encapsulation Mechanism (DEM). DEMs provide authenticated encryption with associated data (AEAD), but on the
 * relaxed assumption that the encryption key is only used for a single message. All DEMs <strong>MUST</strong> be
 * <em>compactly committing</em>. DEMs <em>SHOULD</em> also provide Deterministic Authenticated Encryption (DAE) in the
 * sense of Rogaway and Shrimpton, in case a protocol error or implementation mistake causes a key to be reused.
 */
public interface DEM {
    Map<String, DEM> IMPLS = new ConcurrentHashMap<>();

    static DEM register(DEM dem) {
        var oldDem = IMPLS.putIfAbsent(dem.getAlgorithmIdentifier(), dem);
        if (oldDem != null && oldDem != dem) {
            throw new IllegalStateException("DEM has already been registered with conflicting implementation");
        }
        return dem;
    }

    static Optional<DEM> lookup(String identifier) {
        return Optional.ofNullable(IMPLS.get(identifier));
    }

    /**
     * A DEM implementation based on AES-256 in Synthetic IV (SIV) mode using HMAC-SHA-512 (truncated to 256-bits)
     * for authentication and key derivation.
     */
    DEM A256SIV_HS512 = register(new A256SIVHS512());
    /**
     * A DEM implementation based on XSalsa20 in Synthetic IV (SIV) mode using HMAC-SHA-512 (truncated to 256 bits)
     * for authentication and key derivation.
     */
    DEM XS20SIV_HS512 = register(new XS20SIVHS512());

    /**
     * A unique identifier for the algorithm implemented by this DEM. This should either be a registered standard value,
     * or else have a reasonable chance of being unique (such as prefixed with a vendor-specific identifier).
     * Identifiers should be chosen from the ASCII character set regex <code>[a-zA-Z0-9_-]{1,255}</code>.
     *
     * @return the unique identifier of this DEM algorithm,
     */
    String getAlgorithmIdentifier();

    /**
     * Generates a fresh random key for this DEM.
     *
     * @return the DEM key.
     */
    SecretKey generateKey();

    /**
     * Returns the size of the tag used by this DEM, in bytes.
     *
     * @return the size of the tag generated by this DEM.
     */
    int tagSizeBytes();

    /**
     * Imports some key material and converts it into a suitable DEM key. The key material should be assumed to be of
     * high entropy and indistinguishable from a uniformly-random bit-string of at least 256 bits. The caller is
     * responsible for converting any other key material into a suitable format, for example by application of a
     * suitable Key Derivation Function (KDF).
     *
     * @param keyMaterial the key material.
     * @param offset the offset into the key material to use.
     * @param length the length of key material to import.
     * @return the imported key.
     * @throws IllegalArgumentException if the key material is too short or not suitable for this DEM.
     */
    SecretKey importKey(byte[] keyMaterial, int offset, int length);

    /**
     * Imports some key material and converts it into a suitable DEM key. The key material should be assumed to be of
     * high entropy and indistinguishable from a uniformly-random bit-string of at least 256 bits. The caller is
     * responsible for converting any other key material into a suitable format, for example by application of a
     * suitable Key Derivation Function (KDF).
     *
     * @param keyMaterial the key material.
     * @return the imported key.
     * @throws IllegalArgumentException if the key material is too short or not suitable for this DEM.
     */
    default SecretKey importKey(byte[] keyMaterial) {
        return importKey(keyMaterial, 0, keyMaterial.length);
    }

    /**
     * Performs an unkeyed hash of the given data using a hash function specified by the DEM. The hash function must
     * be collision resistant, providing at least 128-bit security against classical attacks.
     *
     * @param data the data to hash.
     * @return the hash of the data.
     */
    byte[] hash(byte[] data);

    /**
     * Begins a data encapsulation process and returns an object that can be used to continue the encapsulation
     * process. The returned object is {@link AutoCloseable} and should be used with a
     * <em>try-with-resources</em> statement.
     * <p>
     * <strong>NOTE:</strong> data is only guaranteed to be encrypted when the returned object is closed by
     * calling the {@link DataEncapsulator#done()} or {@link DataEncapsulator#close()} methods.
     *
     * @param key the key to use for data encapsulation. This key should only be used to encapsulate a single message.
     * @return the data encapsulation object.
     */
    DataEncapsulator beginEncapsulation(SecretKey key);

    /**
     * Begins a data decapsulation process and returns an object that can be used to continue the decapsulation
     * process. The returned object is {@link AutoCloseable} and should be used with a <em>try-with-resources</em>
     * statement.
     * <p>
     * <strong>NOTE:</strong> data is only guaranteed to be decrypted when the returned object is closed by
     * calling the {@link DataDecapsulator#verify()} ()} or {@link DataDecapsulator#close()} methods. If
     * authentication fails then the input may be wiped.
     *
     * @param key the key to use for decapsulation.
     * @param tag the authentication predicate produced during encapsulation.
     * @return the data decapsulation object.
     */
    DataDecapsulator beginDecapsulation(SecretKey key, byte[] tag);

    /**
     * An object that can be used to encapsulate independent blocks of message data.
     */
    interface DataEncapsulator extends AutoCloseable {
        /**
         * Arranges for the given message block to be authenticated and encrypted at some future time. The block will
         * be encrypted <em>in-place</em> at some time before the {@link #done()} method returns. Precisely when this
         * occurs is implementation-specific.
         *
         * @param message the message block to encrypt.
         * @return the same encapsulator object.
         */
        DataEncapsulator encapsulate(byte[] message);
        DataEncapsulator withContext(byte[]... context);

        KeyAndTag done();

        default void close() {
            done();
        }
    }

    record KeyAndTag(SecretKey key, byte[] tag) {}

    interface DataDecapsulator extends AutoCloseable {
        DataDecapsulator withContext(byte[]... context);
        DataDecapsulator decapsulate(byte[] message);
        Optional<SecretKey> verify();

        default void close() {
            verify().orElseThrow(() -> new IllegalArgumentException("Message authentication failed"));
        }
    }


    /**
     * Convenience method when the DEM is being used for key-wrapping. Encrypts the encoded form of a secret key and
     * returns a ciphertext that combines the encrypted data and the authentication predicate. The original key is not
     * altered or destroyed by this operation.
     *
     * @param wrapKey the key to use for encrypting another key.
     * @param toEncrypt the key to encrypt (wrap).
     * @param context associated data. This should ideally include the key algorithm and any parameters.
     * @return the encrypted key and authentication predicate.
     */
    default byte[] wrap(SecretKey wrapKey, SecretKey toEncrypt, byte[]... context) {
        var encoded = toEncrypt.getEncoded();
        try (var cipher = beginEncapsulation(wrapKey)) {
            var siv = cipher.withContext(context).encapsulate(encoded).done().tag();
            return Utils.concat(siv, encoded);
        } finally {
            Arrays.fill(encoded, (byte) 0);
        }
    }

    default Optional<SecretKey> unwrap(SecretKey wrapKey, byte[] wrappedKey,
                                       Function<byte[], SecretKey> keyConstructor, byte[]... context) {
        var siv = Arrays.copyOfRange(wrappedKey, 0, tagSizeBytes());
        var encoded = Arrays.copyOfRange(wrappedKey, tagSizeBytes(), wrappedKey.length);
        try (var cipher = beginDecapsulation(wrapKey, siv)) {
            return cipher.withContext(context).decapsulate(encoded).verify()
                    .map(ignore -> keyConstructor.apply(encoded));
        } finally {
            Arrays.fill(encoded, (byte) 0);
        }
    }
}
